Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'asserting' stamp: 'alavia 11/23/2017 05:08'!assertHasIdInstanceVariable: aClass 		(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'alavia 11/23/2017 05:07'!assertIsValidFor: aClass 	(aClass classThatDefinesInstanceVariable: instanceVariableName) ifNil: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] 	! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/1/2016 15:59'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:12'!testEmptyLinesAreRecognizedAsInvalidRecords	self		should: [ self importCustomersFrom: self dataWithEmptyLine.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: StreamImporter emptyRecordErrorDescription .			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportAddressRecordWithMoreThanSixFields	self		should: [ self				importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 01:49'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordTypeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 14:04'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: self addressWithoutCustomerTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: AddressRecordImporter  recordWithoutDependencyErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportAddressRecordWithLessThanSixFields	self		should: [ self				importCustomersFrom: self addressRecordWithLessThanSixFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 01:49'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self		should: [ self				importCustomersFrom: self addressRecordStartingWithMoreThanOneATestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 01:39'!testImportCustomers	self importCustomersFrom: self validTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'alavia 11/23/2017 05:36'!alwaysImportedCustomer	^ system		customerIdentifiedAs: (Identification for: self alwaysImportedCustomerIdType and: self alwaysImportedCustomerIdNumber)		ifNone: [ self fail ]! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 05:41'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system		customerIdentifiedAs: (Identification for: idType and: idNumber)		ifNone: [ self fail ].	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 05:37'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := system		customerIdentifiedAs: (Identification for: idType and: idNumber)		ifNone: [ self fail ].	self		assert: customer		isNamed: 'Pepe'		lastName: 'Sanchez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 2.	self		assert: customer		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: customer		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:22'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 13:51'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identification type = idType.	self assert: customer identification number = idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:23'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomersSize equals: 2! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 10:46'!validTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'importing' stamp: 'alavia 11/23/2017 02:12'!importCustomersFrom: inputStream	(StreamImporter from: inputStream on: system ) import! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:45'!setUp	system := Environment current createCustomerSystem.	system start.	system beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 11:25'!tearDown	system commit.	system close! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'actions' stamp: 'alavia 11/23/2017 03:10'!createERPSystemWith: aCustomerSystem and: aSupplierSystem	^ERPSystem with: aCustomerSystem and: aSupplierSystem.! !!Environment class methodsFor: 'actions' stamp: 'RodrigoOscarKapobel 11/20/2017 12:09'!createCustomerSystem	self subclassResponsibility ! !!Environment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:12'!createSupplierSystem	self subclassResponsibility ! !!Environment class methodsFor: 'actions' stamp: 'RodrigoOscarKapobel 11/20/2017 12:05'!isCurrent	self subclassResponsibility! !!Environment class methodsFor: 'accessing' stamp: 'alavia 11/21/2017 23:12'!current	^self subclasses detect: [ :aEnvironmentClass | aEnvironmentClass isCurrent ].! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'actions' stamp: 'alavia 11/23/2017 14:34'!isCurrent	^false.! !!DevelopmentEnvironment class methodsFor: 'actions' stamp: 'alavia 11/22/2017 04:56'!createSupplierSystem	^TransientSupplierSystem new.! !!DevelopmentEnvironment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:13'!createCustomerSystem	^TransientCustomerSystem new.! !Object subclass: #Identification	instanceVariableNames: 'number type'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Identification methodsFor: 'accessing' stamp: 'alavia 11/23/2017 13:52'!number		^number ! !!Identification methodsFor: 'accessing' stamp: 'alavia 11/23/2017 13:52'!number: anIdentificationNumber 	number := anIdentificationNumber! !!Identification methodsFor: 'accessing' stamp: 'alavia 11/23/2017 13:53'!type: anIdentificationType 	type := anIdentificationType! !!Identification methodsFor: 'accessing' stamp: 'alavia 11/23/2017 13:53'!type		^type ! !!Identification methodsFor: 'accessing' stamp: 'alavia 11/23/2017 13:53'!isIdentifiedAs: anIdentification	^(type = anIdentification type ) and: (number = anIdentification number )! !!Identification methodsFor: 'initialization' stamp: 'alavia 11/23/2017 13:53'!initializeWith: anIdType and: anIdNumber 	type := anIdType .	number := anIdNumber .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Identification class	instanceVariableNames: ''!!Identification class methodsFor: 'creation' stamp: 'alavia 11/23/2017 05:35'!for: anIdType and: anIdNumber	^self new initializeWith: anIdType and: anIdNumber ! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:13'!isCurrent	^DevelopmentEnvironment isCurrent not.! !!IntegrationEnvironment class methodsFor: 'actions' stamp: 'alavia 11/22/2017 04:56'!createSupplierSystem	^PersistentSupplierSystem new.	! !!IntegrationEnvironment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:13'!createCustomerSystem	^PersistentCustomerSystem new.! !Object subclass: #Mappers	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mappers class	instanceVariableNames: ''!!Mappers class methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 14:29'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!Mappers class methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 14:28'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!Mappers class methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 14:28'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !Object subclass: #Party	instanceVariableNames: 'identification addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Party methodsFor: 'addresses' stamp: 'alavia 11/23/2017 04:49'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'addresses' stamp: 'alavia 11/23/2017 04:49'!addressesIsEmpty		^addresses isEmpty! !!Party methodsFor: 'addresses' stamp: 'alavia 11/23/2017 04:49'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'addresses' stamp: 'alavia 11/23/2017 04:49'!addresses	^ addresses copy! !!Party methodsFor: 'addresses' stamp: 'alavia 11/23/2017 04:53'!numberOfAddresses		^addresses size! !!Party methodsFor: 'initialization' stamp: 'alavia 11/23/2017 04:57'!initialize	addresses := OrderedCollection new.! !!Party methodsFor: 'identification' stamp: 'alavia 11/23/2017 05:21'!identification		^identification! !!Party methodsFor: 'identification' stamp: 'alavia 11/23/2017 05:22'!isIdentifiedAs: anIdentification	^identification isIdentifiedAs: anIdentification.! !!Party methodsFor: 'identification' stamp: 'alavia 11/23/2017 05:21'!identification: anIdentification 	identification := anIdentification! !Party subclass: #Customer	instanceVariableNames: 'id firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'initialization' stamp: 'alavia 11/23/2017 04:57'!initialize	super initialize.! !Object subclass: #RecordImporter	instanceVariableNames: 'system importer record'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!RecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 01:21'!import	^self subclassResponsibility .! !!RecordImporter methodsFor: 'initialization' stamp: 'alavia 11/23/2017 01:51'!initializeWith: aRecord on: aSystem with: aImporter 	record := aRecord .	system := aSystem .	importer := aImporter .! !!RecordImporter methodsFor: 'accessing' stamp: 'alavia 11/22/2017 23:43'!size	^self subclassResponsibility .! !!RecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:03'!assertValidRecordSize		record size ~= self size ifTrue: [ self signalInvalidRecordSize ].! !!RecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:06'!signalInvalidRecordSize		self error: self class invalidRecordSizeErrorDescription ! !!RecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 14:06'!assertThereIsDependencyForRecord	importer dependant isNil ifTrue: [ self signalRecordWithoutDependencyError ].! !!RecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 14:07'!signalRecordWithoutDependencyError	self error: self class recordWithoutDependencyErrorDescription.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RecordImporter class	instanceVariableNames: ''!!RecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:32'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!RecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 14:07'!recordWithoutDependencyErrorDescription	^'Address without dependency error'.! !!RecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:06'!invalidRecordSizeErrorDescription		^'Invalid record size'! !!RecordImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 00:34'!canImport: aRecord	^self subclassResponsibility .! !!RecordImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 01:53'!for: aRecord on: aSystem with: aImporter	self allSubclasses detect: [ :aRecordImporterClass | aRecordImporterClass canImport: aRecord ] 	ifFound: [ :aRecordImporterClass | ^aRecordImporterClass new initializeWith: aRecord on: aSystem with: aImporter. ]	ifNone: [ self error: self invalidRecordTypeErrorDescription ]! !RecordImporter subclass: #AddressRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!AddressRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 14:02'!import	| newAddress |		self assertValidRecordSize.	self assertThereIsDependencyForRecord.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.		^importer dependant addAddress: newAddress! !!AddressRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 01:29'!size	^6! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddressRecordImporter class	instanceVariableNames: ''!!AddressRecordImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 01:42'!canImport: aRecord	^aRecord first = 'A'.! !RecordImporter subclass: #CustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 13:51'!import	| newCustomer newIdentification |		self assertValidRecordSize.		newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.		newIdentification := Identification new.	newIdentification type: record fourth .	newIdentification number: record fifth .		newCustomer identification: newIdentification.		importer dependant: newCustomer.	system addCustomer: newCustomer.! !!CustomerRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 01:24'!size	^5! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerRecordImporter class	instanceVariableNames: ''!!CustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 01:42'!canImport: aRecord	^aRecord first = 'C'.! !RecordImporter subclass: #ExistingCustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ExistingCustomerRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 14:09'!import	| existingCustomer |		self assertValidRecordSize.	self assertThereIsDependencyForRecord.		existingCustomer := system customerIdentifiedAs: (Identification for: record second and: record third) ifNone: [ self signalExistingCustomerNotPersisted ].	importer dependant addCustomer: existingCustomer! !!ExistingCustomerRecordImporter methodsFor: 'signalling' stamp: 'alavia 11/23/2017 03:36'!signalExistingCustomerNotPersisted 		self error: self class existingCustomerNotPersistedErrorDescription ! !!ExistingCustomerRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:50'!size	^3! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExistingCustomerRecordImporter class	instanceVariableNames: ''!!ExistingCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:45'!canImport: aRecord	^aRecord first = 'EC'.! !!ExistingCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 03:36'!existingCustomerNotPersistedErrorDescription	^'Trying to add an existing customer not persisted before'! !RecordImporter subclass: #NewCustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!NewCustomerRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:39'!size	^5! !!NewCustomerRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 14:09'!import	| newCustomer newIdentification|		self assertValidRecordSize.	self assertThereIsDependencyForRecord.		newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.		newIdentification := Identification new.	newIdentification type: record fourth .	newIdentification number: record fifth .		newCustomer identification: newIdentification.		system addCustomer: newCustomer.	importer dependant addCustomer: newCustomer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NewCustomerRecordImporter class	instanceVariableNames: ''!!NewCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:39'!canImport: aRecord	^aRecord first = 'NC'.! !Object subclass: #StreamImporter	instanceVariableNames: 'line readStream record newCustomer system dependant'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!StreamImporter methodsFor: 'initialization' stamp: 'alavia 11/23/2017 00:09'!initializeOn: aReadStream on: aSystem	readStream := aReadStream.	system := aSystem.! !!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 00:09'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 00:09'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 01:13'!importRecord	| recordImporter |	recordImporter := RecordImporter for: record on: system with: self.	recordImporter import.! !!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 00:33'!assertRecordNotEmpty		record isEmpty ifTrue: [ self error: self class emptyRecordErrorDescription ]! !!StreamImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 00:09'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!StreamImporter methodsFor: 'accessing' stamp: 'alavia 11/23/2017 01:18'!dependant: anObject	dependant := anObject .! !!StreamImporter methodsFor: 'accessing' stamp: 'alavia 11/23/2017 01:18'!dependant	^dependant.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StreamImporter class	instanceVariableNames: ''!!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:09'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:34'!emptyRecordErrorDescription		^'Empty record error'! !!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:09'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:09'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!StreamImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 00:09'!from: aReadStream on: aSystem	^self new initializeOn: aReadStream on: aSystem! !Party subclass: #Supplier	instanceVariableNames: 'id name customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Supplier methodsFor: 'initialization' stamp: 'alavia 11/23/2017 04:57'!initialize	super initialize.	customers := OrderedCollection new.! !!Supplier methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 17:07'!addCustomer: aCustomer 	customers add: aCustomer ! !!Supplier methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 17:09'!numberOfCustomers		^customers size! !!Supplier methodsFor: 'customers' stamp: 'alavia 11/23/2017 04:55'!customers	^ customers copy! !!Supplier methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 17:08'!customersIsEmpty		^customers isEmpty! !!Supplier methodsFor: 'customers' stamp: 'alavia 11/23/2017 06:00'!customerWithIdentification: aIdentification ifNone: noneBlock 		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: aIdentification ] ifNone: noneBlock ! !!Supplier methodsFor: 'name' stamp: 'alavia 11/21/2017 23:46'!name		^name ! !!Supplier methodsFor: 'name' stamp: 'alavia 11/21/2017 23:46'!name: aName 	name := aName! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'supplierSystem customerSystem erpSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:40'!testCanNotImportSupplierRecordWithLessThanFourFields	self		should: [ self				importSuppliersFrom: self supplierRecordWithLessThanFourFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidRecordSizeErrorDescription.			self assert: supplierSystem isSuppliersEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 04:21'!testCanImportSuppliersWithoutCustomers	self importSuppliersFrom: self validTestDataWithoutCustomers.		self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WithoutCustomersWasImportedCorrectly.	! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:42'!testShouldNotImportSupplierRecordsStartingWithMoreThanS	self		should: [ self				importSuppliersFrom: self supplierRecordStartingWithMoreThanOneSTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidRecordTypeErrorDescription.			self assert: supplierSystem isSuppliersEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/22/2017 22:17'!testCanImportSuppliersWithExistingCustomers	self importCustomersFrom: self validTestDataOfCustomerRecord.	self importSuppliersFrom: self validTestDataWithExistingCustomers.		self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WithExistingCustomersWasImportedCorrectly .! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:41'!testCanNotImportSuppliersWithExistingCustomersNotPersistedBefore	self		should: [ self importSuppliersFrom: self validTestDataWithExistingCustomers.		self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ExistingCustomerRecordImporter existingCustomerNotPersistedErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]	! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:40'!testCanNotImportSupplierRecordWithMoreThanFourFields	self		should: [ self				importSuppliersFrom: self supplierRecordWithMoreThanFourFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidRecordSizeErrorDescription.			self assert: supplierSystem isSuppliersEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 04:20'!testCanImportSuppliersWithNewCustomers	self importSuppliersFrom: self validTestDataWithNewCustomers.		self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WithNewCustomersWasImportedCorrectly.	self assert: (customerSystem allCustomersSize) equals: 1! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'RodrigoOscarKapobel 11/20/2017 15:20'!supplierRecordStartingWithMoreThanOneSTestData		^ ReadStream on:'SS,Pepe,D,22333444'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'RodrigoOscarKapobel 11/20/2017 15:37'!supplierRecordWithMoreThanFourFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,',x'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'alavia 11/23/2017 06:02'!alwaysImportedSupplier	^ supplierSystem		supplierIdentifiedAs: (Identification for: self alwaysImportedCustomerIdType and: self alwaysImportedCustomerIdNumber)		ifNone: [ self fail ]! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'RodrigoOscarKapobel 11/20/2017 15:44'!supplierRecordWithLessThanFourFieldsTestData		^ ReadStream on: 'S,Pepe,D'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'alavia 11/21/2017 22:41'!alwaysImportedSupplierRecord	^ 'S,Supplier1,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'RodrigoOscarKapobel 11/20/2017 14:09'!alwaysImportedCustomerIdType	^ 'D'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'alavia 11/22/2017 22:07'!validTestDataOfCustomerRecord	^ReadStream on: 'C,Juan,Perez,D,5456774'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'alavia 11/22/2017 22:14'!alwaysImportedExistingCustomerRecord	^ 'EC,D,5456774'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'RodrigoOscarKapobel 11/20/2017 14:09'!alwaysImportedCustomerIdNumber	^ '22333444'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'RodrigoOscarKapobel 11/20/2017 16:23'!alwaysImportedNewCustomerRecord	^ 'NC,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 13:51'!assert: aSupplier hasCustomerWithFirstName: aFirstName lastName: aLastName idType: anIdType idNumber: anIdNumber 	| customer |		customer := aSupplier customerWithIdentification: (Identification for: anIdType and: anIdNumber) ifNone: [ self fail ].	self assert: customer firstName equals: aFirstName.	self assert: customer lastName equals: aLastName.	self assert: customer identification type equals: anIdType.	self assert: customer identification number equals: anIdNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:30'!assert: aSupplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province 	| address |		address := aSupplier  addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 06:00'!assertSupplier1WithExistingCustomersWasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '22333444'.	supplier := supplierSystem		supplierIdentifiedAs: (Identification for: idType and: idNumber)		ifNone: [ self fail ].	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 1		andNumberOfAddresses: 2.	self		assert: supplier		hasCustomerWithFirstName: 'Juan'		lastName: 'Perez'		idType: 'D'		idNumber: '5456774'.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 05:57'!assertSupplier1WithoutCustomersWasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '22333444'.	supplier := supplierSystem		supplierIdentifiedAs: (Identification for: idType and: idNumber)		ifNone: [ self fail ].	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 0		andNumberOfAddresses: 2.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 06:02'!assertSupplier1WithNewCustomersWasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '22333444'.	supplier := supplierSystem		supplierIdentifiedAs: (Identification for: idType and: idNumber)		ifNone: [ self fail ].	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 1		andNumberOfAddresses: 2.	self		assert: supplier		hasCustomerWithFirstName: 'Pepe'		lastName: 'Sanchez'		idType: idType		idNumber: idNumber.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/22/2017 21:08'!assertImportedSuppliersSizeIsCorrect	self assert: supplierSystem allSuppliersSize equals: 1! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 13:51'!assert: aSupplier isNamed: name identfiedAs: idType withNumber: idNumber numberOfCustomers: customersSize andNumberOfAddresses: addressesSize 	self assert: aSupplier name equals: name.	self assert: aSupplier identification type equals: idType.	self assert: aSupplier identification number equals: idNumber.	self assert: aSupplier numberOfCustomers equals: customersSize.	self assert: aSupplier numberOfAddresses equals: addressesSize.! !!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 16:53'!validTestDataWithNewCustomers	^ ReadStream on: self alwaysImportedSupplierRecord,'',self alwaysImportedNewCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 14:48'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 16:54'!validTestDataWithExistingCustomers	^ ReadStream on: self alwaysImportedSupplierRecord,'',self alwaysImportedExistingCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 16:27'!validTestDataWithoutCustomers	^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'importing' stamp: 'alavia 11/23/2017 03:06'!importCustomersFrom: inputStream	(StreamImporter from: inputStream on: customerSystem ) import! !!SupplierImportTest methodsFor: 'importing' stamp: 'alavia 11/23/2017 03:06'!importSuppliersFrom: inputStream	(StreamImporter from: inputStream on: erpSystem ) import! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 03:12'!setUp		supplierSystem := Environment current createSupplierSystem.		customerSystem := Environment current createCustomerSystem .	erpSystem := Environment current createERPSystemWith: customerSystem and: supplierSystem.	erpSystem start.	erpSystem beginTransaction.! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 03:12'!tearDown	erpSystem commit.	erpSystem close.! !RecordImporter subclass: #SupplierRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 13:51'!import	| newSupplier newIdentification |		self assertValidRecordSize.		newSupplier := Supplier new.	newSupplier name: record second.		newIdentification := Identification new.	newIdentification type: record third .	newIdentification number: record fourth .		newSupplier identification: newIdentification.		importer dependant: newSupplier.	system addSupplier: newSupplier.! !!SupplierRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:50'!size	^4! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierRecordImporter class	instanceVariableNames: ''!!SupplierRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:54'!canImport: aRecord	^aRecord first = 'S'.! !Object subclass: #System	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!System methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 05:10'!start	^self subclassResponsibility .! !!System methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 05:10'!beginTransaction	^self subclassResponsibility .! !!System methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 04:58'!close	^self subclassResponsibility .! !!System methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 05:09'!commit	^self subclassResponsibility .! !System subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!addCustomer: arg1 	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!allCustomersSize	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!close	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!commit	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!start	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!allCustomers	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'alavia 11/23/2017 05:32'!customerIdentifiedAs: anIdentification ifNone: noneBlock 	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!beginTransaction	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!isCustomersEmpty	^ self subclassResponsibility! !System subclass: #ERPSystem	instanceVariableNames: 'systems'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ERPSystem methodsFor: 'reflective operations' stamp: 'alavia 11/23/2017 14:21'!doesNotUnderstand: aMessage	systems detect: [:aSystem | aSystem class allSelectors includes: aMessage selector  ] 	ifFound: [:aSystem | ^aMessage sendTo: aSystem  ]	ifNone: [^super doesNotUnderstand: aMessage ]! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/23/2017 14:16'!start	systems do: [ :aSystem | aSystem start. ]! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/23/2017 14:16'!beginTransaction	systems do: [ :aSystem | aSystem beginTransaction. ]! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/23/2017 14:16'!close	systems do: [ :aSystem | aSystem close. ]! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/23/2017 14:16'!commit	systems do: [ :aSystem | aSystem commit. ]! !!ERPSystem methodsFor: 'initialization' stamp: 'alavia 11/23/2017 14:15'!initializeWith: aCollectionOfSystems	super initialize .	systems := aCollectionOfSystems .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ERPSystem class	instanceVariableNames: ''!!ERPSystem class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 14:14'!with: aCustomerSystem and: aSupplierSystem	| systems |	systems := OrderedCollection new.	systems add: aCustomerSystem .	systems add: aSupplierSystem .	^self with: systems.! !!ERPSystem class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 14:13'!with: aCollectionOfSystems	^self new initializeWith: aCollectionOfSystems .! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentCustomerSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 00:42'!addCustomer: aCustomer	session persist: aCustomer .! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:04'!close	session close! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:04'!commit	session commit! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 14:30'!initializeSession	session := DataBaseSession		for: (Array with: Mappers addressMapping with: Mappers customerMapping)! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:31'!start	session open! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:04'!beginTransaction	session beginTransaction! !!PersistentCustomerSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 01:12'!isCustomersEmpty	^ self allCustomers isEmpty! !!PersistentCustomerSystem methodsFor: 'accesing' stamp: 'alavia 11/23/2017 05:52'!customerIdentifiedAs: anIdentification ifNone: noneBlock	| customers |	customers := session		select: [ :aCustomer | aCustomer isIdentifiedAs: anIdentification ]		ofType: Customer.	customers size = 1		ifTrue: [ ^ customers anyOne ]		ifFalse: noneBlock.	^ self! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'alavia 11/13/2017 20:59'!initialize	super initialize.	self initializeSession.! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'alavia 11/16/2017 20:04'!allCustomers	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 00:22'!allCustomersSize	^ self allCustomers size! !System subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:22'!isSuppliersEmpty	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!commit	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!close	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!allSuppliers	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'alavia 11/23/2017 05:51'!supplierIdentifiedAs: aIdentification ifNone: noneBlock	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'alavia 11/23/2017 06:03'!addSupplier: aSupplier 	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!start	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!allSuppliersSize	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:22'!beginTransaction	^ self subclassResponsibility! !SupplierSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!close	session close! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!commit	session commit! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 14:29'!initializeSession	session := DataBaseSession		for: (Array with: Mappers addressMapping with: Mappers supplierMapping)! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!start	session open! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!beginTransaction	session beginTransaction! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'alavia 11/22/2017 04:48'!initialize	super initialize.	self initializeSession.! !!PersistentSupplierSystem methodsFor: 'accesing' stamp: 'alavia 11/23/2017 05:52'!supplierIdentifiedAs: aIdentification ifNone: noneBlock	| suppliers |	suppliers := session		select: [ :aSupplier | aSupplier isIdentifiedAs: aIdentification ]		ofType: Supplier.	suppliers size = 1		ifTrue: [ ^ suppliers anyOne ]		ifFalse: noneBlock.	^ self! !!PersistentSupplierSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 19:57'!addSupplier: aSupplier	session persist: aSupplier.! !!PersistentSupplierSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:10'!allSuppliersSize	^ self allSuppliers size! !!PersistentSupplierSystem methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 14:06'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 15:24'!isSuppliersEmpty	^ self allSuppliers isEmpty! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientCustomerSystem methodsFor: 'customers' stamp: 'alavia 11/16/2017 20:44'!allCustomers	^customers copy.! !!TransientCustomerSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 19:43'!isCustomersEmpty	^ customers isEmpty! !!TransientCustomerSystem methodsFor: 'initialization' stamp: 'alavia 11/16/2017 20:38'!initialize	super initialize.	customers := OrderedCollection new.! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:45'!commit! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:44'!beginTransaction! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:39'!start! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:45'!close! !!TransientCustomerSystem methodsFor: 'accesing' stamp: 'alavia 11/23/2017 05:54'!customerIdentifiedAs: anIdentification ifNone: noneBlock	customers detect: [:aCustomer | (aCustomer isIdentifiedAs: anIdentification )] ifFound: [:aCustomer | ^aCustomer ]  ifNone: noneBlock .! !!TransientCustomerSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 19:46'!allCustomersSize	^ customers size! !!TransientCustomerSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 00:40'!addCustomer: aCustomer	customers add: aCustomer .! !SupplierSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientSupplierSystem methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 19:45'!allSuppliers	^ suppliers copy! !!TransientSupplierSystem methodsFor: 'initialization' stamp: 'alavia 11/22/2017 04:55'!initialize	super initialize.	suppliers := OrderedCollection new.! !!TransientSupplierSystem methodsFor: 'accesing' stamp: 'alavia 11/23/2017 05:56'!supplierIdentifiedAs: anIdentification ifNone: noneBlock	suppliers detect: [:aSupplier | aSupplier isIdentifiedAs: anIdentification ]	         ifFound: [:aSupplier | ^aSupplier ] 				 ifNone: noneBlock .! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:48'!commit! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:49'!beginTransaction! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:49'!close! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:49'!start! !!TransientSupplierSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 19:46'!allSuppliersSize	^ suppliers size.! !!TransientSupplierSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 19:44'!isSuppliersEmpty	^ suppliers isEmpty! !!TransientSupplierSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 19:57'!addSupplier: aSupplier	suppliers add: aSupplier.! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 23 November 2017 at 2:36:23.526955 pm'!!String methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 23 November 2017 at 2:36:23.527693 pm'!!Object methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !