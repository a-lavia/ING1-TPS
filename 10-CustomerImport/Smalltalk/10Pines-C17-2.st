Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'alavia 11/16/2017 19:38'!alwaysImportedCustomer	^ system		customerIdentifiedAs: self alwaysImportedCustomerIdType		numbered: self alwaysImportedCustomerIdNumber		ifNone: [ self fail ]! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:22'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:22'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:22'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system		customerIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:23'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomersSize equals: 2! !!CustomerImportTest methodsFor: 'asserting' stamp: 'alavia 11/16/2017 19:38'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := system		customerIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: customer		isNamed: 'Pepe'		lastName: 'Sanchez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 2.	self		assert: customer		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: customer		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'importing' stamp: 'alavia 11/23/2017 02:12'!importCustomersFrom: inputStream	(StreamImporter from: inputStream on: system ) import! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:45'!setUp	system := Environment current createCustomerSystem.	system start.	system beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 11:25'!tearDown	system commit.	system close! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 01:39'!testImportCustomers	self importCustomersFrom: self validTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportAddressRecordWithLessThanSixFields	self		should: [ self				importCustomersFrom: self addressRecordWithLessThanSixFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportAddressRecordWithMoreThanSixFields	self		should: [ self				importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 01:49'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self		should: [ self				importCustomersFrom: self addressRecordStartingWithMoreThanOneATestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:08'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordSizeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 02:12'!testEmptyLinesAreRecognizedAsInvalidRecords	self		should: [ self importCustomersFrom: self dataWithEmptyLine.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: StreamImporter emptyRecordErrorDescription .			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 01:49'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: RecordImporter invalidRecordTypeErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 01:43'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: self addressWithoutCustomerTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: AddressRecordImporter  addressWithoutDependencyErrorDescription.			self assert: system isCustomersEmpty ]! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/1/2016 15:59'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 10:46'!validTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'actions' stamp: 'RodrigoOscarKapobel 11/20/2017 12:09'!createCustomerSystem	self subclassResponsibility ! !!Environment class methodsFor: 'actions' stamp: 'alavia 11/23/2017 03:10'!createERPSystemWith: aCustomerSystem and: aSupplierSystem	^ERPSystem with: aCustomerSystem and: aSupplierSystem.! !!Environment class methodsFor: 'actions' stamp: 'alavia 11/23/2017 03:10'!createERPSystem	^self subclassResponsibility .! !!Environment class methodsFor: 'actions' stamp: 'RodrigoOscarKapobel 11/20/2017 12:05'!isCurrent	self subclassResponsibility! !!Environment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:12'!createSupplierSystem	self subclassResponsibility ! !!Environment class methodsFor: 'accessing' stamp: 'alavia 11/21/2017 23:12'!current	^self subclasses detect: [ :aEnvironmentClass | aEnvironmentClass isCurrent ].! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'actions' stamp: 'alavia 11/22/2017 05:30'!createERPSystem	^ERPSystem with: self createCustomerSystem and: self createSupplierSystem .! !!DevelopmentEnvironment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:13'!createCustomerSystem	^TransientCustomerSystem new.! !!DevelopmentEnvironment class methodsFor: 'actions' stamp: 'alavia 11/23/2017 04:01'!isCurrent	^false.! !!DevelopmentEnvironment class methodsFor: 'actions' stamp: 'alavia 11/22/2017 04:56'!createSupplierSystem	^TransientSupplierSystem new.! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'actions' stamp: 'alavia 11/22/2017 05:30'!createERPSystem	^ERPSystem with: self createCustomerSystem and: self createSupplierSystem .! !!IntegrationEnvironment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:13'!isCurrent	^DevelopmentEnvironment isCurrent not.! !!IntegrationEnvironment class methodsFor: 'actions' stamp: 'alavia 11/21/2017 23:13'!createCustomerSystem	^PersistentCustomerSystem new.! !!IntegrationEnvironment class methodsFor: 'actions' stamp: 'alavia 11/22/2017 04:56'!createSupplierSystem	^PersistentSupplierSystem new.	! !Object subclass: #Party	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!Party subclass: #Customer	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'identification' stamp: 'RodrigoOscarKapobel 11/20/2017 01:08'!isIdentifiedAs:anIdentificationType numbered:anIdentificationNumber	^identificationType = anIdentificationType and: 	[identificationNumber = anIdentificationNumber]! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 09:43'!numberOfAddresses		^addresses size! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:27'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:25'!addresses	^ addresses! !!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !!Customer methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/1/2016 10:05'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Customer methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/1/2016 18:03'!addressesIsEmpty		^addresses isEmpty! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !Object subclass: #RecordImporter	instanceVariableNames: 'system importer record'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!RecordImporter methodsFor: 'accessing' stamp: 'alavia 11/22/2017 23:43'!size	^self subclassResponsibility .! !!RecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:03'!assertValidRecordSize		record size ~= self size ifTrue: [ self signalInvalidRecordSize ].! !!RecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:06'!signalInvalidRecordSize		self error: self class invalidRecordSizeErrorDescription ! !!RecordImporter methodsFor: 'initialization' stamp: 'alavia 11/23/2017 01:51'!initializeWith: aRecord on: aSystem with: aImporter 	record := aRecord .	system := aSystem .	importer := aImporter .! !!RecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 01:21'!import	^self subclassResponsibility .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RecordImporter class	instanceVariableNames: ''!!RecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:06'!invalidRecordSizeErrorDescription		^'Invalid record size'! !!RecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:32'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!RecordImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 01:53'!for: aRecord on: aSystem with: aImporter	self allSubclasses detect: [ :aRecordImporterClass | aRecordImporterClass canImport: aRecord ] 	ifFound: [ :aRecordImporterClass | ^aRecordImporterClass new initializeWith: aRecord on: aSystem with: aImporter. ]	ifNone: [ self error: self invalidRecordTypeErrorDescription ]! !!RecordImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 00:34'!canImport: aRecord	^self subclassResponsibility .! !RecordImporter subclass: #AddressRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!AddressRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 01:29'!size	^6! !!AddressRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 01:32'!assertThereIsDependencyForAddress	importer dependant isNil ifTrue: [ self signalAddressWithoutDependencyError ].	! !!AddressRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 02:35'!import	| newAddress |		self assertValidRecordSize.	self assertThereIsDependencyForAddress.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.		^importer dependant addAddress: newAddress! !!AddressRecordImporter methodsFor: 'signalling' stamp: 'alavia 11/23/2017 01:33'!signalAddressWithoutDependencyError	self error: self class addressWithoutDependencyErrorDescription.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddressRecordImporter class	instanceVariableNames: ''!!AddressRecordImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 01:42'!canImport: aRecord	^aRecord first = 'A'.! !!AddressRecordImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 01:35'!addressWithoutDependencyErrorDescription	^'Address without dependency error'.! !RecordImporter subclass: #CustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 02:36'!import	| newCustomer |		self assertValidRecordSize.		newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.		importer dependant: newCustomer.	system addCustomer: newCustomer.! !!CustomerRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 01:24'!size	^5! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerRecordImporter class	instanceVariableNames: ''!!CustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 01:42'!canImport: aRecord	^aRecord first = 'C'.! !RecordImporter subclass: #ExistingCustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ExistingCustomerRecordImporter methodsFor: 'signalling' stamp: 'alavia 11/23/2017 03:36'!signalExistingCustomerNotPersisted 		self error: self class existingCustomerNotPersistedErrorDescription ! !!ExistingCustomerRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:50'!size	^3! !!ExistingCustomerRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 02:47'!import	| existingCustomer |		self assertValidRecordSize.	"falta error dependencia nil"	existingCustomer := system customerIdentifiedAs: record second numbered: record third ifNone: [ self signalExistingCustomerNotPersisted ].	importer dependant addCustomer: existingCustomer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExistingCustomerRecordImporter class	instanceVariableNames: ''!!ExistingCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 03:36'!existingCustomerNotPersistedErrorDescription	^'Trying to add an existing customer not persisted before'! !!ExistingCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:45'!canImport: aRecord	^aRecord first = 'EC'.! !RecordImporter subclass: #NewCustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!NewCustomerRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:39'!size	^5! !!NewCustomerRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 02:41'!import	| newCustomer |		self assertValidRecordSize.	"falta error dependencia nil"	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.		system addCustomer: newCustomer.	importer dependant addCustomer: newCustomer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NewCustomerRecordImporter class	instanceVariableNames: ''!!NewCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:39'!canImport: aRecord	^aRecord first = 'NC'.! !Object subclass: #StreamImporter	instanceVariableNames: 'line readStream record newCustomer system dependant'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 01:13'!importRecord	| recordImporter |	recordImporter := RecordImporter for: record on: system with: self.	recordImporter import.! !!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 00:09'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 00:09'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!StreamImporter methodsFor: 'importing - private' stamp: 'alavia 11/23/2017 00:33'!assertRecordNotEmpty		record isEmpty ifTrue: [ self error: self class emptyRecordErrorDescription ]! !!StreamImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 00:09'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!StreamImporter methodsFor: 'accessing' stamp: 'alavia 11/23/2017 01:18'!dependant: anObject	dependant := anObject .! !!StreamImporter methodsFor: 'accessing' stamp: 'alavia 11/23/2017 01:18'!dependant	^dependant.! !!StreamImporter methodsFor: 'initialization' stamp: 'alavia 11/23/2017 00:09'!initializeOn: aReadStream on: aSystem	readStream := aReadStream.	system := aSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StreamImporter class	instanceVariableNames: ''!!StreamImporter class methodsFor: 'instance creation' stamp: 'alavia 11/23/2017 00:09'!from: aReadStream on: aSystem	^self new initializeOn: aReadStream on: aSystem! !!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:09'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:09'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:34'!emptyRecordErrorDescription		^'Empty record error'! !!StreamImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 00:09'!invalidAddressRecordErrorDescription		^'Invalid address record'! !Party subclass: #Supplier	instanceVariableNames: 'id name identificationType identificationNumber addresses customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Supplier methodsFor: 'name' stamp: 'alavia 11/21/2017 23:46'!name		^name ! !!Supplier methodsFor: 'name' stamp: 'alavia 11/21/2017 23:46'!name: aName 	name := aName! !!Supplier methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 17:07'!customers	^ customers! !!Supplier methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 17:07'!addCustomer: aCustomer 	customers add: aCustomer ! !!Supplier methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 17:09'!numberOfCustomers		^customers size! !!Supplier methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 17:08'!customersIsEmpty		^customers isEmpty! !!Supplier methodsFor: 'addresses' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!addresses	^ addresses! !!Supplier methodsFor: 'addresses' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!numberOfAddresses		^addresses size! !!Supplier methodsFor: 'addresses' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!addAddress: anAddress 	addresses add: anAddress ! !!Supplier methodsFor: 'addresses' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!addressesIsEmpty		^addresses isEmpty! !!Supplier methodsFor: 'initialization' stamp: 'RodrigoOscarKapobel 11/20/2017 17:21'!initialize	super initialize.	addresses := OrderedCollection new.	customers := OrderedCollection new.! !!Supplier methodsFor: 'identification' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!identificationType		^identificationType ! !!Supplier methodsFor: 'identification' stamp: 'alavia 11/23/2017 03:51'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Supplier methodsFor: 'identification' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!identificationNumber		^identificationNumber ! !!Supplier methodsFor: 'identification' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Supplier methodsFor: 'identification' stamp: 'RodrigoOscarKapobel 11/20/2017 13:28'!isIdentifiedAs:anIdentificationType numbered:anIdentificationNumber	^identificationType = anIdentificationType and: 	[identificationNumber = anIdentificationNumber]! !!Supplier methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 17:07'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Supplier methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 18:35'!customerWithIdType: anIdType andIdNumber: anIdNumber ifNone: noneClosure 		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdType numbered: anIdNumber ] ifNone: noneClosure ! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'supplierSystem customerSystem erpSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 16:53'!validTestDataWithNewCustomers	^ ReadStream on: self alwaysImportedSupplierRecord,'',self alwaysImportedNewCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 16:27'!validTestDataWithoutCustomers	^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 16:54'!validTestDataWithExistingCustomers	^ ReadStream on: self alwaysImportedSupplierRecord,'',self alwaysImportedExistingCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'RodrigoOscarKapobel 11/20/2017 14:48'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'importing' stamp: 'alavia 11/23/2017 03:06'!importCustomersFrom: inputStream	(StreamImporter from: inputStream on: customerSystem ) import! !!SupplierImportTest methodsFor: 'importing' stamp: 'alavia 11/23/2017 03:06'!importSuppliersFrom: inputStream	(StreamImporter from: inputStream on: erpSystem ) import! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 04:20'!assertSupplier1WithNewCustomersWasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '22333444'.	supplier := supplierSystem		supplierIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 1		andNumberOfAddresses: 2.	self		assert: supplier		hasCustomerWithFirstName: 'Pepe'		lastName: 'Sanchez'		idType: idType		idNumber: idNumber.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:30'!assert: aSupplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province 	| address |		address := aSupplier  addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/22/2017 22:20'!assertSupplier1WithExistingCustomersWasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '22333444'.	supplier := supplierSystem		supplierIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 1		andNumberOfAddresses: 2.	self		assert: supplier		hasCustomerWithFirstName: 'Juan'		lastName: 'Perez'		idType: 'D'		idNumber: '5456774'.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/21/2017 22:46'!assert: aSupplier isNamed: name identfiedAs: idType withNumber: idNumber numberOfCustomers: customersSize andNumberOfAddresses: addressesSize 	self assert: aSupplier name equals: name.	self assert: aSupplier identificationType equals: idType.	self assert: aSupplier identificationNumber equals: idNumber.	self assert: aSupplier numberOfCustomers equals: customersSize.	self assert: aSupplier numberOfAddresses equals: addressesSize.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/22/2017 21:08'!assertImportedSuppliersSizeIsCorrect	self assert: supplierSystem allSuppliersSize equals: 1! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/23/2017 04:21'!assertSupplier1WithoutCustomersWasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '22333444'.	supplier := supplierSystem		supplierIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 0		andNumberOfAddresses: 2.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'alavia 11/21/2017 22:46'!assert: aSupplier hasCustomerWithFirstName: aFirstName lastName: aLastName idType: anIdType idNumber: anIdNumber 	| customer |		customer := aSupplier customerWithIdType: anIdType andIdNumber: anIdNumber ifNone: [ self fail ].	self assert: customer firstName equals: aFirstName.	self assert: customer lastName equals: aLastName.	self assert: customer identificationType equals: anIdType.	self assert: customer identificationNumber equals: anIdNumber.! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 04:20'!testCanImportSuppliersWithNewCustomers	self importSuppliersFrom: self validTestDataWithNewCustomers.		self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WithNewCustomersWasImportedCorrectly.	self assert: (customerSystem allCustomersSize) equals: 1! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:40'!testCanNotImportSupplierRecordWithLessThanFourFields	self		should: [ self				importSuppliersFrom: self supplierRecordWithLessThanFourFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidRecordSizeErrorDescription.			self assert: supplierSystem isSuppliersEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:42'!testShouldNotImportSupplierRecordsStartingWithMoreThanS	self		should: [ self				importSuppliersFrom: self supplierRecordStartingWithMoreThanOneSTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidRecordTypeErrorDescription.			self assert: supplierSystem isSuppliersEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 04:21'!testCanImportSuppliersWithoutCustomers	self importSuppliersFrom: self validTestDataWithoutCustomers.		self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WithoutCustomersWasImportedCorrectly.	! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:41'!testCanNotImportSuppliersWithExistingCustomersNotPersistedBefore	self		should: [ self importSuppliersFrom: self validTestDataWithExistingCustomers.		self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ExistingCustomerRecordImporter existingCustomerNotPersistedErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]	! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:40'!testCanNotImportSupplierRecordWithMoreThanFourFields	self		should: [ self				importSuppliersFrom: self supplierRecordWithMoreThanFourFieldsTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidRecordSizeErrorDescription.			self assert: supplierSystem isSuppliersEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/23/2017 03:40'!testCanNotImportAddressWithoutSupplier	self		should: [ self importSuppliersFrom: self addressWithoutCustomerTestData.			self ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: AddressRecordImporter  addressWithoutDependencyErrorDescription.			self assert: supplierSystem isSuppliersEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'alavia 11/22/2017 22:17'!testCanImportSuppliersWithExistingCustomers	self importCustomersFrom: self validTestDataOfCustomerRecord.	self importSuppliersFrom: self validTestDataWithExistingCustomers.		self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WithExistingCustomersWasImportedCorrectly .! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'RodrigoOscarKapobel 11/20/2017 16:02'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedSupplierRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'RodrigoOscarKapobel 11/20/2017 16:04'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636'! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'RodrigoOscarKapobel 11/20/2017 16:07'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'RodrigoOscarKapobel 11/20/2017 14:51'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'RodrigoOscarKapobel 11/20/2017 16:23'!alwaysImportedNewCustomerRecord	^ 'NC,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'alavia 11/22/2017 22:14'!alwaysImportedExistingCustomerRecord	^ 'EC,D,5456774'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'RodrigoOscarKapobel 11/20/2017 14:09'!alwaysImportedCustomerIdType	^ 'D'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'alavia 11/22/2017 22:07'!validTestDataOfCustomerRecord	^ReadStream on: 'C,Juan,Perez,D,5456774'! !!SupplierImportTest methodsFor: 'test data - customer' stamp: 'RodrigoOscarKapobel 11/20/2017 14:09'!alwaysImportedCustomerIdNumber	^ '22333444'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'RodrigoOscarKapobel 11/20/2017 15:44'!supplierRecordWithLessThanFourFieldsTestData		^ ReadStream on: 'S,Pepe,D'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'RodrigoOscarKapobel 11/20/2017 15:37'!supplierRecordWithMoreThanFourFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,',x'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'alavia 11/21/2017 22:41'!alwaysImportedSupplierRecord	^ 'S,Supplier1,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'alavia 11/22/2017 21:08'!alwaysImportedSupplier	^ supplierSystem		supplierIdentifiedAs: self alwaysImportedCustomerIdType		numbered: self alwaysImportedCustomerIdNumber		ifNone: [ self fail ]! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'RodrigoOscarKapobel 11/20/2017 15:20'!supplierRecordStartingWithMoreThanOneSTestData		^ ReadStream on:'SS,Pepe,D,22333444'! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 03:12'!setUp		supplierSystem := Environment current createSupplierSystem.		customerSystem := Environment current createCustomerSystem .	erpSystem := Environment current createERPSystemWith: customerSystem and: supplierSystem.	erpSystem start.	erpSystem beginTransaction.! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'alavia 11/23/2017 03:12'!tearDown	erpSystem commit.	erpSystem close.! !RecordImporter subclass: #SupplierRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierRecordImporter methodsFor: 'importing' stamp: 'alavia 11/23/2017 02:48'!import	| newSupplier |		self assertValidRecordSize.		newSupplier := Supplier new.	newSupplier name: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.		importer dependant: newSupplier.	system addSupplier: newSupplier.! !!SupplierRecordImporter methodsFor: 'asserting' stamp: 'alavia 11/23/2017 02:50'!size	^4! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierRecordImporter class	instanceVariableNames: ''!!SupplierRecordImporter class methodsFor: 'error descriptions' stamp: 'alavia 11/23/2017 02:54'!canImport: aRecord	^aRecord first = 'S'.! !Object subclass: #System	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!System subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!allCustomersSize	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!close	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!commit	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!allCustomers	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!start	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!isCustomersEmpty	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!beginTransaction	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!addCustomer: arg1 	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:20'!customerIdentifiedAs: arg1 numbered: arg2 ifNone: arg3 	^ self subclassResponsibility! !System subclass: #ERPSystem	instanceVariableNames: 'customerSystem supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ERPSystem methodsFor: 'initialization' stamp: 'alavia 11/22/2017 04:26'!initializeWith: aCustomerSystem and: aSupplierSystem	super initialize .	customerSystem := aCustomerSystem .	supplierSystem := aSupplierSystem .! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/22/2017 04:45'!commit	customerSystem commit .	supplierSystem commit .! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/22/2017 04:45'!close	customerSystem close .	supplierSystem close .! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/22/2017 04:46'!start	customerSystem start .	supplierSystem start .! !!ERPSystem methodsFor: 'accessing' stamp: 'alavia 11/22/2017 04:45'!beginTransaction	customerSystem beginTransaction .	supplierSystem beginTransaction .! !!ERPSystem methodsFor: 'asserting' stamp: 'alavia 11/22/2017 05:37'!allSuppliersSize	^supplierSystem allSuppliersSize .! !!ERPSystem methodsFor: 'identification' stamp: 'alavia 11/23/2017 03:46'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!ERPSystem methodsFor: 'adding' stamp: 'alavia 11/22/2017 04:44'!addSupplier: aSupplier	supplierSystem addSupplier: aSupplier .! !!ERPSystem methodsFor: 'adding' stamp: 'alavia 11/22/2017 04:43'!addCustomer: aCustomer	customerSystem addCustomer: aCustomer.! !!ERPSystem methodsFor: 'accesing' stamp: 'alavia 11/22/2017 05:39'!customerIdentifiedAs: aString numbered: aString2 ifNone: aBlockClosure 	^customerSystem customerIdentifiedAs: aString numbered: aString2 ifNone: aBlockClosure ! !!ERPSystem methodsFor: 'accesing' stamp: 'alavia 11/22/2017 05:37'!supplierIdentifiedAs: aString numbered: aString2 ifNone: aBlockClosure 	^supplierSystem supplierIdentifiedAs: aString numbered: aString2 ifNone: aBlockClosure ! !!ERPSystem methodsFor: 'testing' stamp: 'alavia 11/22/2017 05:38'!isSuppliersEmpty	^supplierSystem isSuppliersEmpty .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ERPSystem class	instanceVariableNames: ''!!ERPSystem class methodsFor: 'as yet unclassified' stamp: 'alavia 11/22/2017 04:25'!with: aCustomerSystem and: aSupplierSystem	^self new initializeWith: aCustomerSystem and: aSupplierSystem .! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentCustomerSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 00:42'!addCustomer: aCustomer	session persist: aCustomer .! !!PersistentCustomerSystem methodsFor: 'accesing' stamp: 'alavia 11/16/2017 20:04'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	| customers |	customers := session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer.	customers size = 1		ifTrue: [ ^ customers anyOne ]		ifFalse: noneBlock.	^ self! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:04'!commit	session commit! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:04'!close	session close! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:04'!beginTransaction	session beginTransaction! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:31'!start	session open! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/13/2017 20:54'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/13/2017 20:56'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentCustomerSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 11:51'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping)! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'alavia 11/13/2017 20:59'!initialize	super initialize.	self initializeSession.! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'alavia 11/16/2017 20:04'!allCustomers	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 00:22'!allCustomersSize	^ self allCustomers size! !!PersistentCustomerSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 01:12'!isCustomersEmpty	^ self allCustomers isEmpty! !System subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:22'!isSuppliersEmpty	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!close	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!allSuppliers	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!commit	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!start	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!allSuppliersSize	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:22'!beginTransaction	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!supplierIdentifiedAs: arg1 numbered: arg2 ifNone: arg3 	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'accessing' stamp: 'RodrigoOscarKapobel 11/20/2017 22:21'!addSupplier: arg1 	^ self subclassResponsibility! !SupplierSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentSupplierSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 19:57'!addSupplier: aSupplier	session persist: aSupplier.! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!commit	session commit! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!close	session close! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!beginTransaction	session beginTransaction! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!start	session open! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/21/2017 22:34'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 12:28'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentSupplierSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/21/2017 23:40'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self supplierMapping)! !!PersistentSupplierSystem methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 14:06'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'alavia 11/22/2017 04:48'!initialize	super initialize.	self initializeSession.! !!PersistentSupplierSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 14:10'!allSuppliersSize	^ self allSuppliers size! !!PersistentSupplierSystem methodsFor: 'accesing' stamp: 'RodrigoOscarKapobel 11/20/2017 14:17'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	| suppliers |	suppliers := session		select: [ :aSupplier | 			aSupplier identificationType = anIdentifycationType				and: [ aSupplier identificationNumber = anIdentificationNumber ] ]		ofType: Supplier.	suppliers size = 1		ifTrue: [ ^ suppliers anyOne ]		ifFalse: noneBlock.	^ self! !!PersistentSupplierSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 15:24'!isSuppliersEmpty	^ self allSuppliers isEmpty! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientCustomerSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 19:43'!isCustomersEmpty	^ customers isEmpty! !!TransientCustomerSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 00:40'!addCustomer: aCustomer	customers add: aCustomer .! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'alavia 11/16/2017 20:44'!allCustomers	^customers copy.! !!TransientCustomerSystem methodsFor: 'accesing' stamp: 'RodrigoOscarKapobel 11/20/2017 01:07'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	customers detect: [:aCustomer | (aCustomer isIdentifiedAs: anIdentifycationType  numbered: anIdentificationNumber)]	         ifFound: [:aCustomer | ^aCustomer ] 				 ifNone: noneBlock .! !!TransientCustomerSystem methodsFor: 'initialization' stamp: 'alavia 11/16/2017 20:38'!initialize	super initialize.	customers := OrderedCollection new.! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:45'!commit! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:39'!start! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:45'!close! !!TransientCustomerSystem methodsFor: 'setup-teardown' stamp: 'alavia 11/16/2017 20:44'!beginTransaction! !!TransientCustomerSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 19:46'!allCustomersSize	^ customers size! !SupplierSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientSupplierSystem methodsFor: 'testing' stamp: 'RodrigoOscarKapobel 11/20/2017 19:44'!isSuppliersEmpty	^ suppliers isEmpty! !!TransientSupplierSystem methodsFor: 'persistance' stamp: 'RodrigoOscarKapobel 11/20/2017 19:57'!addSupplier: aSupplier	suppliers add: aSupplier.! !!TransientSupplierSystem methodsFor: 'accesing' stamp: 'RodrigoOscarKapobel 11/20/2017 19:52'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	suppliers detect: [:aSupplier | (aSupplier isIdentifiedAs: anIdentifycationType  numbered: anIdentificationNumber)]	         ifFound: [:aSupplier | ^aSupplier ] 				 ifNone: noneBlock .! !!TransientSupplierSystem methodsFor: 'asserting' stamp: 'RodrigoOscarKapobel 11/20/2017 19:46'!allSuppliersSize	^ suppliers size.! !!TransientSupplierSystem methodsFor: 'customers' stamp: 'RodrigoOscarKapobel 11/20/2017 19:45'!allSuppliers	^ suppliers copy! !!TransientSupplierSystem methodsFor: 'initialization' stamp: 'alavia 11/22/2017 04:55'!initialize	super initialize.	suppliers := OrderedCollection new.! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:48'!commit! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:49'!close! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:49'!start! !!TransientSupplierSystem methodsFor: 'setup-teardown' stamp: 'RodrigoOscarKapobel 11/20/2017 19:49'!beginTransaction! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 23 November 2017 at 4:22:42.866675 am'!!String methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 23 November 2017 at 4:22:42.867539 am'!!Object methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !